name: Build and Push Multi-Arch OCI Image (JFrog CLI)

on:
  push:
    branches:
      - master
  workflow_dispatch:

env:
  # This uses the Public IP you set in the ARTIFACTORY_URL secret.
  ARTIFACTORY_ADDRESS: ${{ secrets.ARTIFACTORY_URL }} 
  
  # YOUR OCI repository key
  OCI_REPO: pratham-oci-oc-local 
  IMAGE_NAME: my-multiarch-app
  IMAGE_TAG: latest

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: ‚¨áÔ∏è Checkout repository
        uses: actions/checkout@v4

      - name: üèóÔ∏è Set up QEMU for cross-platform builds
        uses: docker/setup-qemu-action@v3

      - name: üõ†Ô∏è Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ‚öôÔ∏è Setup JFrog CLI and Configuration
        # This step loads the JF_ARTIFACTORY_CONFIG secret for authentication.
        uses: jfrog/setup-jfrog-cli@v3
        env:
          JF_ARTIFACTORY: ${{ secrets.JF_ARTIFACTORY_CONFIG }}

      - name: üöÄ Build and Push Multi-Architecture Image (Initial Push)
        run: |
          # The full target path uses the public address from secrets
          FULL_IMAGE_TAG="${{ env.ARTIFACTORY_ADDRESS }}/${{ env.OCI_REPO }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"

          # 1. Build the multi-arch image using Docker Buildx
          # We build to a local tar file to manage the push via JFrog CLI
          docker buildx build --platform linux/amd64,linux/arm64 --tag $FULL_IMAGE_TAG --output=type=docker,dest=/tmp/output.tar .
          
          # 2. Load the build output back into the local Docker daemon
          docker load --input /tmp/output.tar
          
          # 3. Use JFrog CLI to push the multi-arch image (Initial Upload)
          echo "Initial Push of Multi-Arch Image with JFrog CLI..."
          jf rt docker-push $FULL_IMAGE_TAG ${{ env.OCI_REPO }}

      - name: üè∑Ô∏è Re-Push the same image with a new tag (Replication Test)
        run: |
          FULL_IMAGE_PATH="${{ env.ARTIFACTORY_ADDRESS }}/${{ env.OCI_REPO }}/${{ env.IMAGE_NAME }}"
          NEW_TAG="retest-tag"
          
          # 1. Tag the existing multi-arch image with a new tag
          echo "Tagging image with new tag: ${NEW_TAG}"
          jf rt docker-tag $FULL_IMAGE_PATH:${{ env.IMAGE_TAG }} $FULL_IMAGE_PATH:${NEW_TAG}
          
          # 2. Push the new tag and OBSERVE THE LOGS HERE
          echo "Pushing new tag (${NEW_TAG}) with JFrog CLI..."
          echo "Expected Result: Artifactory will only upload the manifest/metadata."
          jf rt docker-push $FULL_IMAGE_PATH:${NEW_TAG} ${{ env.OCI_REPO }}
          
          echo "--- REPLICATION CHECK COMPLETE: Review logs for layer skipping confirmation. ---"
